---
title: "Вокруг браузерных API: Console API"
slug: browser-apis-console
publishDate: 2020-11-12T10:53:48.380Z
thumbnail: /assets/web-apis-console.jpg
unsplashLink: https://unsplash.com/@markusspiske
unsplashAuthor: Markus Spiske
description: Посмотрим, что полезного можно почерпнуть из Console API за
  пределами console.log и как различаются реализации интерфейса между браузерами
tags:
  - API
  - Console
---
## Семантика логов

Console API предоставляет несколько методов, которые работают одинаково, различаясь только семантикой, то есть назначением лога. **console.log** -- семантически нейтрален, его можно сравнить с тегом div в HTML, когда остальные методы можно сравнить с тегами header, footer, main, section и т.д. -- аналогичные блоки, но уже с семантической спецификой.

Эти методы:

1. **console.log** -- семантически нейтральный лог
2. **console.debug** -- сообщение отладки
3. **console.info** -- информационное сообщение
4. **console.warn** -- предупреждение
5. **console.error** -- сообщение об ошибке

При использовании семантически окрашенного метода браузер может применить к логу дополнительную стилизацию и расширить функционал -- эта реализация идёт на усмотрение браузера, так что она отличается. Например, если это ошибка, то логично использовать **console.error** вместо **console.log**, чтобы получить не просто текст, а окрашенное в красный цвет сообщение со стек трейсом.

Метод **console.debug**, как мне кажется, среди них наименее известный, что удивительно, ведь большинство разработчиков используют логи именно для отладки, так что применение этого метода было бы предпочтительнее.

![Сравнение 5 методов лога в консоли Chrome](/assets/chrome-semantics.png "Chrome. debug выделен цветом, info не отличается от log, warn и error выделяются иконками и цветом и снабжены стек трейсом")

![Сравнение 5 методов лога в консоли Firefox](/assets/firefox-semantics.png "Firefox. debug не отличается от log, info выделен иконкой, warn и error – иконками и фоном, у error стек трейс")

![Сравнение 5 методов лога в консоли Safari](/assets/safari-semantics.png "Safari. У всех своя иконка, warn и error выделены фоном, у error стек трейс")

Помимо изменения визуальной составляющей сообщений devtools поддерживают фильтрацию по типу логов: так мы можем выбрать только интересующие уровни логов, например скрыть назойливые варнинги из дебрей node_modules. Реализация фильтров между браузерами разнится, и отличаются сами группы фильтров.

![Реализация фильтров в Chrome devtools](/assets/chrome-filters.png "Chrome. log и info объединены в одну группу Info, для отображения debug нужно активировать группу Verbose. Реализация через множественный селект. По дефолту активированы все группы кроме Verbose, что, как говорит молодёжь, \\"сос мыслом\\", т.к. сообщения дебага, которые можно пропустить при разработке, исчезают из консоли")

![Реализация фильтров в Firefox devtools](/assets/firefox-filters.png "Firefox. log и info в отдельных группах Logs и Info, под debug так же отдельная группа Debug. Реализация через кнопки-тогглы. По дефолту выбраны все группы")

![Реализация фильтров в Safari devtools](/assets/safari-filters.png "Safari. log, info и debug объединены в одну группу Logs. Реализация не позволяет выбирать несколько групп, и при выборе исчезает код. По дефолту выбрана опция All")

Соблюдая семантику, логи легче визуально различать, к ним может добавляться вспомогательный функционал на рассмотрение браузера вроде стек трейса для **console.error**, и мы можем использовать фильтры. К тому же за таким кодом проще следить: например, при выкате в прод найти поиском по проекту все сообщения **console.debug** и удалить, а ещё лучше настроить линтер на вывод варнингов на дебаги через правило [no-console](https://eslint.org/docs/rules/no-console).

## Строковые подстановки

Чтобы вывести строку, содержащую переменные, можно попробовать передать в **console.log** (или в его семантических побратимов) несколько аргументов, но в результате выведется не единая строка, а несколько отдельных переменных. Вместо этого можно использовать шаблонные строки -- это уже рабочий вариант. Альтернативно в методах консоли можно использовать подстановки как в Сишнике! Первым аргументом передаём шаблон строки со специальными директивами вместо переменных, а следующими аргументами загружаем переменные, которые встанут на их место.

![Сравнение подходов к выводу составных строк в консоли Firefox](/assets/firefox-substitutions.png "Firefox. 4 варианта вывода составной строки разной степени паршивости")

Из директив доступны строки **%s**, целые числа **%d** (**%i**), числа с плавающей запятой **%f** и объекты **%o** (**%O**). Числа дополнительно поддерживают форматирование по типу **%.2f** , чего не добиться через шаблонные строки. Chrome на удивление их не поддерживает, однако ничего страшного не произойдёт, если написать -- просто в этом браузере выведется неотформатированное число (progressive enhancement, все дела).

Подстановки -- классная вещь, добавляющая вашим логам свэга. Их даже проще читать, чем шаблонные строки, на мой субъективный вкус. Ну и возможность форматирования здесь как вишенка на торте.

### Стилизация сообщений

Внешний вид сообщений можно настраивать — для этого существует специальная директива **%c**. Синтаксис аналогичен остальным подстановкам — указываете начало стилизованного текста в шаблоне, вторым аргументом передаёте CSS аналогично инлайну в атрибут style. Большинство CSS стилей, которые вы в обиходе используете для форматирования, здесь поддерживается (даже повторяющиеся радиальные градиенты!). Но опять же, зависит от браузера, например Firefox'у и Safari как-то не понравились мои вертикальные поля.

![Стилизованное сообщение "We are hiring!" в консоли Chrome](/assets/chrome-styles.png "Chrome. Некоторые конторы любят оставлять подобные пасхалки для потенциальных соискателей")

*Вы можете задаться вопросом: "Можно ли разукрасить только часть сообщения?". Ну... синтаксиса для закрытия директивы в API нет, но это не мешает добавить вторую директиву, которая будет обнулять стили. Так что да, это возможно: `console.log('White %cRed%c White', 'color: red;', '')`.*

## Логирование объектов

**console.log** нормально справляется с выводом объектов в консоль, но посмотрим какие есть альтернативы.

### console.dir

Метод выводит переданный объект в виде интерактивного набора полей. Логика такая, что **console.dir** выводит всегда строго объект, а **console.log** подстраивается под контекст и использует наиболее подходящее отображение.

![Сравнение результатов log и dir для объектного литерала в консоли Chrome](/assets/chrome-dir-log.png "Chrome. log принял более наглядный вид чем строгий dir, при раскрытии идентичны")

![Сравнение результатов log и dir для объектного литерала в консоли Firefox](/assets/firefox-dir-log.png "Firefox. Опять же log поприятнее, раскрытые совпадают, но dir сразу раскрыт")

![Сравнение результатов log и dir для объектного литерала в консоли Safari](/assets/safari-dir-log.png "Safari. log для литерала вообще не выводит дерева, dir аналогичен другим браузерам")

DOM элементы -- тоже объекты, но особенные. При выводе DOM элемента в консоли браузер вместо набора полей может отобразить фрагмент разметки, аналогичный вкладке Elements. Чтобы настоять на выводе разметки, придуман метод **console.dirxml**.

![Сравнение результатов log, dirxml и dir для document.head в консоли Chrome](/assets/chrome-dir.png "Chrome. log и dirxml выводят разметку, dir – объект")

![Сравнение результатов log, dirxml и dir для document.head в консоли Firefox](/assets/firefox-dir.png "Firefox. Не умеет в вывод разметки: все методы выводят представление через объект, просто результат dir развёрнут по умолчанию")

![Сравнение результатов log, dirxml и dir для document.head в консоли Safari](/assets/safari-dir.png "Safari. Поведение аналогично Chrome")

Суммируя, особого профита в использовании **console.dir** и **console.dirxml** нет, т.к. **console.log** в современных браузерах довольно умный. Ранее он выводил для объектов результат **toString()**, но сейчас всё на высшем уровне. Разве что, вы точно знаете какое отображение вам нужно, тогда эти более строгие методы — ваш выбор.

### console.table

Метод представляет объект (или массив, но массив в JS тоже объект, так что...) через стильную таблицу. Идеально подходит для отображения крупных объектов без лишних вложенностей, т.к. подаёт информацию более наглядно. Например, вы мутите датавиз и хотите ознакомиться со структурой данных -- самое то.

![Данные по 20 фильмам, представленные в виде таблицы, в консоли Chrome](/assets/chrome-table.png "Chrome. Таблица выводится полностью, поддерживает сортировку, содержимое вложенных объектов не уточняется. Также под таблицей выводится результат метода console.dir")

![Данные по 20 фильмам, представленные в виде таблицы, в консоли Firefox](/assets/firefox-table.png "Firefox. Таблица фиксированной высоты со скроллом, сортировки нет, со вложенными объектами можно взаимодействовать")

![Данные по 20 фильмам, представленные в виде таблицы, в консоли Safari](/assets/safari-table.png "Safari. Таблица выводится полностью, поддерживает сортировку, вложенные объекты вообще не показываются")

**console.table** поддерживает второй аргумент -- список колонок для отображения. Так для нагруженного фрагмента данных исполнение `console.table(data, ['title', 'budget', 'revenue'])` оставит только важные для последующей обработки поля.

![Данные по 20 фильмам с уменьшенным числом колонок в консоли Chrome](/assets/chrome-table-columns.png "Chrome. За счёт вывода только релевантных столбцов значительно снижается визуальный шум")

## По верхам остальных методов

API предоставляет достаточно методов для более специфичных задач. Вкратце что это за методы, и когда они могут пригодиться:

1. **console.count** -- выводит количество собственных вызовов. При отладке при подсчёте числа вызовов некоторого фрагмента кода крутые челиксы могут написать `console.count()` и сразу получить в консоли число вместо того, чтобы писать что-то вроде  `console.log('test')` и вести подсчёт числа выведенных строк. Передавая аргументом лейбл, можно создать несколько счётчиков. Через **console.countReset** можно сбрасывать счётчик в ноль
2. **console.time** -- замеряет время. **console.time** запускает счётчик, **console.timeEnd** -- останавливает и логирует время, через **console.timeLog** выводится время во время работы таймера. Подойдёт для простейших замеров -- для полноценного мониторинга предпочтительнее [Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)
3. **console.group** -- проставляется между логами для группировки в аккордеоны. **console.group** начинает группу, **console.groupEnd** завершает, и **console.groupCollapsed** аналогичен **console.group**, только группа сворачивается по дефолту. Одна из таких фич, которая используется примерно никогда, но просто нужно помнить, что она есть, если вдруг понадобится
4. **console.assert** -- вывод сообщения об ошибке, если предположение неверно (возвращает "falsy value"). Читай, нативная имплементация assertion library
5. **console.trace** -- выводит стек трейс для места программы, из которого вызван. При передаче аргументов просто выведет их рядом аналогично логу
6. **console.clear** -- очистка консоли. Для программной очистки, во всех devtools для этого и так есть специальная кнопка

- - -

Console API предоставляет достаточно много методов для достижения цели вывода в консоль чего-либо. Из всего описанного я бы выделил следующий набор рекомендаций для становления лучшего себя:

1. Использовать **console.debug** при отладке более корректно, нежели **console.log**
2. Вызов семантически окрашенных **console.info**, **console.warn** и **console.error** добавляет возможностей в devtools
3. Вывод составных строк может быть проще с директивами подстановки аля **%s**
4. **%c** -- это такая же директива, только для стилизации, где вторым аргументом идёт инлайновый CSS
5. В некоторых случаях для логировании объекта **console.table** может дать более наглядный результат
6. Держать в голове список возможностей API, которые в определённых случаях могут оказаться полезны